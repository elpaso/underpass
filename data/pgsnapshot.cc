//
// Copyright (c) 2020, 2021 Humanitarian OpenStreetMap Team
//
// This file is part of Underpass.
//
//     Underpass is free software: you can redistribute it and/or modify
//     it under the terms of the GNU General Public License as published by
//     the Free Software Foundation, either version 3 of the License, or
//     (at your option) any later version.
//
//     Underpass is distributed in the hope that it will be useful,
//     but WITHOUT ANY WARRANTY; without even the implied warranty of
//     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//     GNU General Public License for more details.
//
//     You should have received a copy of the GNU General Public License
//     along with Underpass.  If not, see <https://www.gnu.org/licenses/>.
//

// This is generated by autoconf
#ifdef HAVE_CONFIG_H
# include "unconfig.h"
#endif

#include <string>
#include <vector>
#include <array>
#include <memory>
#include <iostream>
#include <pqxx/pqxx>

// The Dump handler
#include <osmium/handler/dump.hpp>
#include <boost/date_time.hpp>
#include "boost/date_time/posix_time/posix_time.hpp"
using namespace boost::posix_time;
using namespace boost::gregorian;

#include "data/pgsnapshot.hh"
#include "log.hh"
using namespace logger;

namespace pgsnapshot {

logger::LogFile& dbglogfile = logger::LogFile::getDefaultInstance();

// These tables are empty by default, and only used when applying a changeset
// pgsnapshot.state
// id | tstamp | sequence_number | state_timestamp | disabled 
//
// pgsnapshot.locked
// id | started | process | source | location | write_lock
//
// pgsnapshot.actions
// data_type | action | id
//
// pgsnapshot.replication_changes
// id | tstamp | nodes_modified | nodes_added | nodes_deleted | ways_modified | ways_added | ways_deleted | relations_modified | relations_added | relations_deleted | changesets_applied | earliest_timestamp | latest_timestamp
//
// pgsnapshot.sql_changes
// id | tstamp | entity_id | type | changeset_id | change_time | action | query | arguments
bool
PGSnapshot::connect(const std::string &dbname, const std::string &server)
{
    std::string args;
    if (dbname.empty()) {
	args = "dbname = pgsnapshot";
    } else {
	args = "dbname = " + dbname;
    }
    
    try {
	db = new pqxx::connection(args);
	if (db->is_open()) {
	    return true;
	} else {
	    return false;
	}
    } catch (const std::exception &e) {
	log_error(e.what());
	return false;
   }    
}


// pgsnapshot.users
// id | name
bool
PGSnapshot::addUser(long uid, const std::string &user)
{
    std::string query = "INSERT INTO users VALUES(";
    query += std::to_string(uid) + ",\'" + user;
    query += "\') ON CONFLICT DO NOTHING;";
    worker = new pqxx::work(*db);
    pqxx::result result = worker->exec(query);
    worker->commit();

    // FIXME: this should return a real value
    return false;
}

// pgsnapshot.nodes
// id | version | user_id | tstamp | changeset_id | tags | geom
bool
PGSnapshot::addNode(const osmium::Node& node)
{
    std::string query = "INSERT INTO nodes(id, version, user_id, tstamp, changeset_id, tags, geom) VALUES(";
    query += std::to_string(node.id()) + ",";
    query += + node.version();
    query += "," + std::to_string(node.uid()) + ",\'" + node.user() + "\'";
    query += ",\'" + node.timestamp().to_iso() + "\'";
    query += "\'," + node.changeset();
    query += "\'," + node.location().x();
    query += ") ON CONFLICT DO NOTHING;";
    log_debug(_("Query: %1%"), query);
    
    worker = new pqxx::work(*db);
    pqxx::result result = worker->exec(query);
    worker->commit();

    // FIXME: this should return a real value
    return false;
}

// pgsnapshot.ways
// id | version | user_id | tstamp | changeset_id | tags | nodes | bbox | linestring
//
// pgsnapshot.way_nodes
// way_id | node_id | sequence_id
bool
PGSnapshot::addWay(const osmium::Way& way)
{
    std::string query = "INSERT INTO ways(id,version,user_id,tstamp,changeset_id,tags,nodes,bbox,linestring) VALUES(";
    query += std::to_string(way.id()) + "," + std::to_string(way.version());
    query += "\') ON CONFLICT DO NOTHING;";
    query += "," + std::to_string(way.uid()) + ",\'" + way.user() + "\'";
    query += ",\'" + way.timestamp().to_iso() + "\'";
    query += "\'," + way.changeset();

    worker = new pqxx::work(*db);
    pqxx::result result = worker->exec(query);
    int i = 0;
    for (const osmium::NodeRef& nref : way.nodes()) {
        log_debug(_("ref: %1%"), nref.ref());
    }
    
    // for (const osmium::Tag& t : way.tags()) {
    //     log_debug("\t", t.key(), "=", t.value());
    //     query = "INSERT INTO way_nodes(way_id,node_id,sequence_id) VALUES(";
    //     query += std::to_string(way.id()) + ",");
    //     query += "\') ON CONFLICT DO NOTHING;";
    // }
    
    
    worker->commit();

    // FIXME: this should return a real value
    return false;
}

// pgsnapshot.relations
// id | version | user_id | tstamp | changeset_id | tags
//
// pgsnapshot.relation_members
// relation_id | member_id | member_type | member_role | sequence_id
bool
PGSnapshot::addRelation(const osmium::Relation& relation)
{

}

}       // EOF pgsnapshot

