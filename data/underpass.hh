//
// Copyright (c) 2020, 2021 Humanitarian OpenStreetMap Team
//
// This file is part of Underpass.
//
//     Underpass is free software: you can redistribute it and/or modify
//     it under the terms of the GNU General Public License as published by
//     the Free Software Foundation, either version 3 of the License, or
//     (at your option) any later version.
//
//     Underpass is distributed in the hope that it will be useful,
//     but WITHOUT ANY WARRANTY; without even the implied warranty of
//     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//     GNU General Public License for more details.
//
//     You should have received a copy of the GNU General Public License
//     along with Underpass.  If not, see <https://www.gnu.org/licenses/>.
//

#ifndef __UNDERPASS_HH__
#define __UNDERPASS_HH__

// This is generated by autoconf
#ifdef HAVE_CONFIG_H
#include "unconfig.h"
#endif

#include <future>
#include <iostream>
#include <pqxx/pqxx>
#include <string>
#include <vector>

#include <condition_variable>
#include <mutex>
#include <thread>

#include "boost/date_time/posix_time/posix_time.hpp"
#include <boost/date_time.hpp>
using namespace boost::posix_time;
using namespace boost::gregorian;

#include <boost/asio/connect.hpp>
#include <boost/asio/ip/tcp.hpp>
#include <boost/asio/ssl/error.hpp>
#include <boost/asio/ssl/stream.hpp>
#include <boost/beast/core.hpp>
#include <boost/beast/http.hpp>
#include <boost/beast/http/parser.hpp>
#include <boost/beast/version.hpp>

namespace beast = boost::beast;
namespace net = boost::asio;
namespace ssl = boost::asio::ssl;
namespace http = beast::http;
using tcp = net::ip::tcp;

#include "data/pq.hh"
#include "osmstats/osmstats.hh"
#include "osmstats/replication.hh"

namespace replication {
class StateFile;
};

/// \file underpass.hh
/// \brief Underpass for monitoring the OSM planet server for replication files.
///
/// These are the underpass used to download and apply the replication files
/// to a database. The monitor the OSM planet server for updated replication
/// files.

/// \namespace underpass
namespace underpass {

class Underpass : public pq::Pq
{
  public:
    /// Connect to the Underpass database
    Underpass(void) = default;
    Underpass(const std::string &dburl);
    void dump(void);

    /// Update the creator table to track editor statistics
    bool updateCreator(long user_id, long change_id, const std::string &editor);

    /// Write the stored data on the directories and timestamps
    /// on the planet server.
    bool writeState(replication::StateFile &state);

    /// Get the state.txt file data by it's path
    std::shared_ptr<replication::StateFile>
    getState(replication::frequency_t freq, const std::string &path);

    /// Get the state.txt date by timestamp
    std::shared_ptr<replication::StateFile>
    getState(replication::frequency_t freq, ptime &tstamp);

    /// Get the state.txt date by sequence
    std::shared_ptr<replication::StateFile>
    getState(replication::frequency_t freq, long sequence);

    /// Get the state.txt data greater than \a timestamp.
    std::shared_ptr<replication::StateFile>
    getStateGreaterThan(replication::frequency_t freq, ptime &timestamp);

    /// Get the state.txt data greater than \a sequence.
    std::shared_ptr<replication::StateFile>
    getStateGreaterThan(replication::frequency_t freq, long sequence);

    /// Get the state.txt data less than \a timestamp.
    std::shared_ptr<replication::StateFile>
    getStateLessThan(replication::frequency_t freq, ptime &timestamp);

    /// Get the state.txt data less than \a sequence.
    std::shared_ptr<replication::StateFile>
    getStateLessThan(replication::frequency_t freq, long sequence);

    /// Get the maximum timestamp for the state.txt data
    std::shared_ptr<replication::StateFile>
    getLastState(replication::frequency_t freq);

    /// Get the minimum timestamp for the state.txt data
    std::shared_ptr<replication::StateFile>
    getFirstState(replication::frequency_t freq);

    std::shared_ptr<osmstats::RawCountry>
    getCountry(double max_lat, double max_lon, double min_lat, double min_lon);

    std::string parsePath(const std::string &url)
    {
        // return url.substr();
        // FIXME: this needs to parse a full URL, and return the file path
        return url;
    };

    ///
    /// \brief freq_to_string returns a string representation of the given \a frequency.
    /// The string representation can be used as part of the path for replication URL
    /// (day, hour, minute, changesets).
    /// \param frequency the frequency enum value.
    /// \return a string representation of the frequency.
    ///
    static std::string freq_to_string(replication::frequency_t frequency)
    {
        return frequency_tags[frequency];
    };

    ///
    /// \brief freq_from_string returns a frequency from its string representation \a frequency_str.
    /// \param frequency_str the string representation (day, hour, minute, changesets).
    /// \return the enum value for \a frequency_str.
    /// \throws std::invalid_argument if the \a frequency_str is not a valid frequency.
    ///
    static replication::frequency_t
    freq_from_string(const std::string &frequency_str)
    {
        for (const auto &[key, value] : frequency_tags)
            if (value == frequency_str)
                return key;
        throw std::invalid_argument("Invalid frequency: " + frequency_str);
    };

    // protected:
    static std::map<replication::frequency_t, std::string> frequency_tags;
    std::string db_url;

  private:
    /// Creates a (possibly invalid) state from a \a where condition and \a order_by SQL, LIMIT 1 is always appended.
    std::shared_ptr<replication::StateFile>
    stateFromQuery(const std::string &where, const std::string &order_by = "");
};

} // namespace underpass

#endif // EOF __UNDERPASS_HH__
