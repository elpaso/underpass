//
// Copyright (c) 2020, Humanitarian OpenStreetMap Team
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
// * Redistributions of source code must retain the above copyright notice, this
//   list of conditions and the following disclaimer.
//
// * Redistributions in binary form must reproduce the above copyright notice,
//   this list of conditions and the following disclaimer in the documentation
//   and/or other materials provided with the distribution.
//
// * Neither the name of copyright holder nor the names of its
//   contributors may be used to endorse or promote products derived from
//   this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//

// This is generated by autoconf
#ifdef HAVE_CONFIG_H
# include "hotconfig.h"
#endif

#include <string>
#include <vector>
#include <array>
#include <memory>
#include <codecvt>
#include <iostream>
#include <pqxx/pqxx>

// The Dump handler
#include <osmium/handler/dump.hpp>
#include <osmium/osm/box.hpp>
#include <boost/date_time.hpp>
#include <boost/algorithm/string.hpp>
#include "boost/date_time/posix_time/posix_time.hpp"
using namespace boost::posix_time;
using namespace boost::gregorian;
#include <boost/geometry.hpp>
#include <boost/geometry/geometries/point_xy.hpp>
#include <boost/geometry/geometries/linestring.hpp>
#include <boost/geometry/geometries/polygon.hpp>
#include <boost/geometry/geometries/geometries.hpp>

#include "hotosm.hh"
#include "data/pgsnapshot.hh"
#include "data/import.hh"

namespace import {

typedef boost::geometry::model::d2::point_xy<double> point_t;
typedef boost::geometry::model::polygon<point_t> polygon_t;
typedef boost::geometry::model::linestring<point_t> linestring_t;

// These tables are empty by default, and only used when applying a changeset
// pgsnapshot.state
// id | tstamp | sequence_number | state_timestamp | disabled 
//
// pgsnapshot.locked
// id | started | process | source | location | write_lock
//
// pgsnapshot.actions
// data_type | action | id
//
// pgsnapshot.replication_changes
// id | tstamp | nodes_modified | nodes_added | nodes_deleted | ways_modified | ways_added | ways_deleted | relations_modified | relations_added | relations_deleted | changesets_applied | earliest_timestamp | latest_timestamp
//
// pgsnapshot.sql_changes
// id | tstamp | entity_id | type | changeset_id | change_time | action | query | arguments
bool
OSMHandler::connect(const std::string &dbname, const std::string &server)
{
    std::string args;
    if (dbname.empty()) {
	args = "dbname = pgsnap";
    } else {
	args = "dbname = " + dbname;
    }
    
    try {
	db = new pqxx::connection(args);
	if (db->is_open()) {
	    return true;
	} else {
	    return false;
	}
    } catch (const std::exception &e) {
	std::cerr << e.what() << std::endl;
	return false;
   }    
}


// pgsnapshot.users
// id | name
bool
OSMHandler::addUser(long uid, const std::string &user)
{
    std::string query = "INSERT INTO users VALUES(";
    std::string tmp = user;
    // some user names have an embeded quote
    boost::algorithm::replace_all(tmp, "\'", "&quot;");
    query += std::to_string(uid) + ",\'" + tmp;
    query += "\') ON CONFLICT DO NOTHING;";
    worker = new pqxx::work(*db);
    pqxx::result result = worker->exec(query);
    worker->commit();

    // FIXME: this should return a real value
    return false;
}

void
OSMHandler::way(const osmium::Way& way)
{
    std::cout << "way " << way.id()
              << ", Changeset: " << way.changeset()
              << ", Version: " << way.version()
              << ", UID: " << way.uid()
              << ", User: " << way.user()
              << ", Timestamp: " << way.timestamp() << std::endl;
    // Setup the tags
    std::string tags;
    for (const osmium::Tag& t : way.tags()) {
        std::cout << "\t" << t.key() << "=" << t.value() << std::endl;
        tags += "\"";
        tags += t.key();
        tags += "\"=>\"";
        // Replace single quotes, as they screw up the query
        std::string tmp = t.value();
        boost::algorithm::replace_all(tmp, "\'", "&quot;");
        // Some values have a double quote, which is unnecesary, and
        // screws up XML parsing.
        boost::algorithm::replace_all(tmp, "\"", "");
        tags += tmp;
        tags += "\", ";
    }
    tags = tags.substr(0, tags.size()-2);

    // Setup the node refs
    std::string refs;
    for (const osmium::NodeRef& nref : way.nodes()) {
        refs += std::to_string(nref.ref()) + ", ";
        // const osmium::Location loc = nref.location();
    }
    refs = refs.substr(0, refs.size()-2);

    // Get the bounding box of the way
    linestring_t lines;
    for (const osmium::NodeRef& nref : way.nodes()) {
        std::cout << "ref:  " << nref.ref() << std::endl;
        // If the location data is bad, drop it
        if (cache[nref.ref()]) {
            boost::geometry::append(lines, point_t(cache[nref.ref()].lat(), cache[nref.ref()].lon()));
        } else {
            std::cout << "ERROR: bad location data in " << nref.ref() <<  std::endl;
        }
    }

    // pgsnapshot.ways
    // id | version | user_id | tstamp | changeset_id | tags | nodes | bbox | linestring
    std::string query;
    query = "INSERT INTO ways(id,version,user_id,tstamp,changeset_id,tags,nodes,bbox,linestring) VALUES(";
    query += std::to_string(way.id()) + ",";
    query += std::to_string(way.version());
    query += "," + std::to_string(way.uid());
    query += ",\'" + way.timestamp().to_iso() + "\'";
    query += "," + std::to_string(way.changeset());
    query += ",\'" + tags + "\', ";
    query += "ARRAY[" + refs += "], ";
    // FIXME: this whole method should probably use ostringstream
    boost::geometry::model::box<point_t> box;
    boost::geometry::envelope(lines, box);
    std::ostringstream bbox;
    bbox << boost::geometry::wkt(box);
    query += "ST_GeomFromText(\'" + bbox.str() + "\', 4326)";
    // Sometimes short linestrings have bad location data. In that
    // case, substitute the bounding box. This is wrong of course.
    // FIXME: see if bad location data can be handled better, or
    // maybe it's a bug
    if (boost::geometry::length(lines) > 0) {
        std::ostringstream linestrings;
        linestrings << boost::geometry::wkt(lines);
        query += ", ST_GeomFromText(\'" + linestrings.str() + "\', 4326";
    } else {
        query += ", ST_GeomFromText(\'" + bbox.str() + "\', 4326";
    }
    query += ")) ON CONFLICT DO NOTHING;";
    std::cout << "Query: " << query << std::endl;

    worker = new pqxx::work(*db);
    pqxx::result result = worker->exec(query);
    // pgsnapshot.way_nodes
    // way_id | node_id | sequence_id
    int i = 0;
    for (const osmium::NodeRef& nref : way.nodes()) {
        query = "INSERT INTO way_nodes(way_id, node_id, sequence_id) VALUES(";
        query += std::to_string(way.id());
        query += ", " + std::to_string(nref.ref());
        query += ", " + std::to_string(i++) + ")  ON CONFLICT DO NOTHING;";
        // std::cout << "Query: " << query << std::endl;
        pqxx::result result = worker->exec(query);
    }

    worker->commit();

    addUser(way.uid(), way.user());

    // Empty the node cache so it doesn't grow out of control
    if (cache.size() > 1000) {
        //cache.clear();
        // cache.erase(0, 20);
    }
}

void
OSMHandler::node(const osmium::Node& node) {
    std::cout << "node " << node.id()
              << ", Changeset: " << node.changeset()
              << ", Version: " << node.version()
              << ", UID: " << node.uid()
              << ", User: " << node.user()
              << ", Timestamp: " << node.timestamp() << std::endl;

    cache[node.id()] = node.location();

    // Use a stringstream to handle unicode conversion
    std::stringstream ss;
    std::string tags;
    for (const osmium::Tag& t : node.tags()) {
        std::cout << "\t" << t.key() << "=" << t.value() << std::endl;
        tags += "\"";
        tags += t.key();
        tags += "\"=>\"";
        // Replace single quotes, as they screw up the query
        std::string tmp = t.value();
        boost::algorithm::replace_all(tmp, "\'", "&quot;");
        boost::algorithm::replace_all(tmp, "\"", "&quot;");
        // "&apos;" is not a supported HTML 4 entity
        boost::algorithm::replace_all(tmp, "&apos;", "&rsquo;");
        // boost::algorithm::replace_all(tmp, "&apos;", "&#39;;");
        ss << "\"" << t.key() << "\"=>\"" << tmp << "\", ";
        tags += "\", ";
        tags = ss.str();
    }
    tags = tags.substr(0, tags.size()-2);

    // pgsnapshot.nodes
    // id | version | user_id | tstamp | changeset_id | tags | geom
    std::string query = "INSERT INTO nodes(id, version, user_id, tstamp, changeset_id, tags, geom) VALUES(";
    query += std::to_string(node.id()) + ",";
    query += std::to_string(node.version());
    query += "," + std::to_string(node.uid());
    query += ",\'" + node.timestamp().to_iso() + "\'";
    query += "," + std::to_string(node.changeset());
    query += ",\'" + tags + "\', ";
    query += "ST_GeomFromText('POINT(" + std::to_string(node.location().lon()) + " ";
    query += std::to_string(node.location().lat()) + ")\'";
    query += ", 4326)) ON CONFLICT DO NOTHING;";
    std::cout << "Query: " << query << std::endl;
    
    worker = new pqxx::work(*db);
    pqxx::result result = worker->exec(query);
    worker->commit();

    addUser(node.uid(), node.user());
}

void
OSMHandler::relation(const osmium::Relation& rel)
{
    std::cout << "rel " << rel.id() << std::endl;
    for (const osmium::Tag& t : rel.tags()) {
        std::cout << "\t" << t.key() << "=" << t.value() << std::endl;
    }
    // pgsnapshot.relations
    // id | version | user_id | tstamp | changeset_id | tags
    //
    // pgsnapshot.relation_members
    // relation_id | member_id | member_type | member_role | sequence_id

}

}       // EOF namespace import

