//
// Copyright (c) 2020, 2021 Humanitarian OpenStreetMap Team
//
// This file is part of Underpass.
//
//     Underpass is free software: you can redistribute it and/or modify
//     it under the terms of the GNU General Public License as published by
//     the Free Software Foundation, either version 3 of the License, or
//     (at your option) any later version.
//
//     Underpass is distributed in the hope that it will be useful,
//     but WITHOUT ANY WARRANTY; without even the implied warranty of
//     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//     GNU General Public License for more details.
//
//     You should have received a copy of the GNU General Public License
//     along with Underpass.  If not, see <https://www.gnu.org/licenses/>.
//

// This is generated by autoconf
#ifdef HAVE_CONFIG_H
# include "unconfig.h"
#endif

#include <string>
#include <vector>
#include <iostream>
#include <fstream>
#include <algorithm>
#include <boost/algorithm/string.hpp>

#include "yaml.hh"
#include "log.hh"

/// \file yaml.cc
/// \brief Simple YAML file reader.

using namespace logger;

/// \namespace yaml
namespace yaml {

void
Yaml::read(const std::string &fspec)
{
    std::ifstream yaml;
    std::string line;
    std::string::size_type pos1, pos2;
    std::string key;
    std::string value;
    std::vector<std::string> entries;

    filespec = fspec;

    try {
        yaml.open(filespec,  std::ifstream::in);
        log_debug(_("Opened %1%"), filespec);
    }
    catch(std::exception& e) {
        log_error(_("Couildn't open %1% %2%"), filespec, e.what());
        return;
    }
        
    while (getline(yaml, line)) {
	boost::algorithm::trim_left(line);
	// boost::algorithm::trim(line);
        // std::cerr << '\"' << line << '\"'<< std::endl;
	// Ignore blank lines
	if (line.empty()) {
	    continue;
	}
	// Ignore comments
        if (line.front() == '#') {
            continue;
        }
	line.erase(0,2);
	// std::cerr << '\"' << line << '\"'<< std::endl;
	// It's a new keyword
        if (line.back() == ':') {
	    line.pop_back();
	    key = line;
        } else {
	    if (key.empty()) {
		config[line] = entries;
	    } else {
		config[key].push_back(line);
	    }
        }
    }
}

void Yaml::dump(void)
{
    std::cerr << std::endl << "Dumping yaml file: " << filespec << std::endl;
    
    for (auto cit = std::begin(config); cit != std::end(config); ++cit) {
	std::cerr << "\tKey: " << cit->first << std::endl;
        if ( cit->second.size() == 0) {
            continue;
        }
        std::vector<std::string> value = cit->second;
        std::cerr << "\t\tValues: ";
        for (auto vit = std::begin(value); vit != std::end(value); ++vit) {
            std::cerr << *vit << ", ";
        }
        std::cerr << std::endl;
    }
}

} // EOF yaml namespace

// Local Variables:
// mode: C++
// indent-tabs-mode: t
// End:
