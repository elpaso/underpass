//
// Copyright (c) 2020, 2021 Humanitarian OpenStreetMap Team
//
// This file is part of Underpass.
//
//     Underpass is free software: you can redistribute it and/or modify
//     it under the terms of the GNU General Public License as published by
//     the Free Software Foundation, either version 3 of the License, or
//     (at your option) any later version.
//
//     Underpass is distributed in the hope that it will be useful,
//     but WITHOUT ANY WARRANTY; without even the implied warranty of
//     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//     GNU General Public License for more details.
//
//     You should have received a copy of the GNU General Public License
//     along with Underpass.  If not, see <https://www.gnu.org/licenses/>.
//

// This is generated by autoconf
#ifdef HAVE_CONFIG_H
# include "unconfig.h"
#endif

#include <string>
#include <vector>
#include <iostream>
#include <fstream>
#include <algorithm>

#include "yaml.hh"
#include "log.hh"

/// \file yaml.cc
/// \brief Simple YAML file reader.

using namespace logger;

/// \namespace yaml
namespace yaml {

void
Yaml::read(const std::string &fspec)
{
    std::ifstream yaml;
    std::string line;
    std::string::size_type pos1, pos2;
    std::string key;
    std::string value;
    std::vector<std::string> entries;

    filespec = fspec;

    try {
        yaml.open(filespec,  std::ifstream::in);
        log_debug(_("Opened %1%"), filespec);
    }
    catch(std::exception& e) {
        log_error(_("Couildn't open %1% %2%"), filespec, e.what());
        return;
    }
        
    while (getline(yaml, line)) {
        // std::cerr << line << std::endl;
        if (line.size() == 0) {
            continue;
        }
        
        pos1 = line.find('#');
        if (pos1 != std::string::npos) {
            continue;
        }
        pos1 = line.find('-');
        pos2 = line.rfind(':');
        if (pos2 != std::string::npos) {
            if (pos1 != std::string::npos) {
                key = line.substr(pos1+2, pos2+2);
            }
            pos2 = key.rfind(':');
            if (pos2 != std::string::npos && pos2 == key.size()-1) {
                key.erase(key.size()-1);
            }   
            config[key] = entries;
        } else {
            value = line.substr(pos1 + 2);
            config[key].push_back(value);
        }
    }
}

void Yaml::dump(void)
{
    std::cerr << std::endl << "Dumping yaml file: " << filespec << std::endl;
    
    for (auto cit = std::begin(config); cit != std::end(config); ++cit) {
	std::cerr << "\t\tKey: " << cit->first << std::endl;
        if ( cit->second.size() == 0) {
            continue;
        }
        std::vector<std::string> value = cit->second;
        std::cerr << "\t\t\t\tValues: ";
        for (auto vit = std::begin(value); vit != std::end(value); ++vit) {
            std::cerr << *vit << ", ";
        }
        std::cerr << std::endl;
    }
}

} // EOF yaml namespace

