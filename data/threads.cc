//
// Copyright (c) 2020, Humanitarian OpenStreetMap Team
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
// * Redistributions of source code must retain the above copyright notice, this
//   list of conditions and the following disclaimer.
//
// * Redistributions in binary form must reproduce the above copyright notice,
//   this list of conditions and the following disclaimer in the documentation
//   and/or other materials provided with the distribution.
//
// * Neither the name of copyright holder nor the names of its
//   contributors may be used to endorse or promote products derived from
//   this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//

// This is generated by autoconf
#ifdef HAVE_CONFIG_H
# include "hotconfig.h"
#endif

#include <string>
#include <vector>
#include <iostream>
#include <mutex>
#include <range/v3/all.hpp>
#include <algorithm>
#include <iterator>
#include <thread>
#include <fstream>
#include <future>
#include <unistd.h>

#include <boost/format.hpp>
#include <boost/asio.hpp>
#include <boost/filesystem.hpp>
#include <boost/asio/ssl/error.hpp>
#include <boost/asio/ssl/stream.hpp>
#include <boost/beast/http/parser.hpp>
#include <boost/beast/core.hpp>
#include <boost/beast/http.hpp>
#include <boost/beast/version.hpp>
#include <boost/algorithm/string.hpp>
#include <boost/iostreams/device/array.hpp>
#include <boost/iostreams/filtering_stream.hpp>
#include <boost/date_time.hpp>
#include "boost/date_time/posix_time/posix_time.hpp"
using namespace boost::posix_time;
using namespace boost::gregorian;
#include <boost/iostreams/filtering_streambuf.hpp>
#include <boost/iostreams/filter/gzip.hpp>
namespace beast = boost::beast;     // from <boost/beast.hpp>
namespace net = boost::asio;        // from <boost/asio.hpp>
namespace ssl = boost::asio::ssl;   // from <boost/asio/ssl.hpp>
namespace http = beast::http;       // from <boost/beast/http.hpp>
using tcp = net::ip::tcp;           // from <boost/asio/ip/tcp.hpp>

#include "data/threads.hh"
#include "osmstats/osmstats.hh"
#include "osmstats/osmchange.hh"
#include "osmstats/changeset.hh"
#include "osmstats/replication.hh"

std::mutex stream_mutex;

namespace threads {

// Starting with this URL, download the file, incrmenting
void
startMonitor(const std::string &url)
{
    auto planet = std::make_shared<replication::Planet>();
    replication::Replication server;
    bool mainloop = true;
    std::string path = url;
    std::string base = url.substr(0, url.size() - 7);
    while (mainloop) {
        // Look for the statefile first
        //std::shared_ptr<replication::StateFile> state = threadStateFile(planet->stream, path);
        bool subloop = true;
#if 0
        while (subloop) {
            std::shared_ptr<replication::StateFile> exists = planet->getState(path);
            if (!exists->path.empty()) {
                std::cout << "Already stored: " << path << std::endl;
                subloop = true;
                break;
            } else {
                std::cout << "Downloading StateFile: " << path << std::endl;
                auto state = threadStateFile(planet->stream, path + ".state.txt");
                if (state->timestamp != boost::posix_time::not_a_date_time && (state->sequence != 0 && state->path.size() != 0)) {
                    state->dump();
                    planet->writeState(*state);
                    subloop = false;
                }
            }
        }
#endif
        if (path.find("changeset") != std::string::npos) {
            std::string file = path + ".osm.gz";
            // std::promise<bool> exists;
            // std::thread osm(&threads::threadChangeSet, std::ref(file), std::move(exists));
            // osm.join();
            // auto found = exists.get_future();
            Timer timer;
            timer.startTimer();
            bool found = threadChangeSet(file);
            if (!found) {
                planet->disconnectServer();
                if (url.find("minute") != std::string::npos) {
                    std::this_thread::sleep_for(std::chrono::minutes{1});
                } else if (url.find("hour") != std::string::npos) {
                    std::this_thread::sleep_for(std::chrono::hours{1});
                } else if (url.find("day") != std::string::npos) {
                    std::this_thread::sleep_for(std::chrono::hours{24});
                }
                planet.reset(new replication::Planet);
            } else {
                std::cout << "Processed ChangeSet: " << path << std::endl;
            }
            timer.endTimer("changeset");
        // planet->db->deactivate();
        } else {
            std::string file = path + ".osc.gz";
            // std::thread osm(threads::threadOsmChange, std::ref(file));
            // osm.detach();
            bool found = threadOsmChange(file);
            if (!found) {
                planet->disconnectServer();
                if (url.find("minute") != std::string::npos) {
                    std::this_thread::sleep_for(std::chrono::minutes{1});
                } else if (url.find("hour") != std::string::npos) {
                    std::this_thread::sleep_for(std::chrono::hours{1});
                } else if (url.find("day") != std::string::npos) {
                    std::this_thread::sleep_for(std::chrono::hours{24});
                }
                planet.reset(new replication::Planet);
            } else {
                std::cout << "Processed OsmChange: " << path << std::endl;
            }
        }
        std::vector<std::string> result;
        // The path is always something like this:
        // https://planet.openstreetmap.org/replication/minute/004/304/997.osm.gz
        // so it's safe to just grab the directory entries we need. Every directory
        /// has 1000 files in it, so the minor needs to get incremented.
        boost::split(result, path, boost::is_any_of("/"));
        int major = 0;
        int minor = 0;
        int index = 0;
        try {
            major = std::stoi(result[5]);
            minor = std::stoi(result[6]);
            index = std::stoi(result[7]);
        } catch (std::exception& e) {
            std::cerr << "ERROR: Couldn't parse: " << path << std::endl;
            std::cerr << e.what() << std::endl;
            continue;
        }

        // Increment the index number
        path = base;
        boost::format fmt("%03d");
        if (minor == 999) {
            major++;
            fmt % (major);
            path += fmt.str() + "/000";
            index = 0;
        }
        if (index == 999) {
            minor++;
            fmt % (minor);
            path += fmt.str();
            path += "/000";
        } else {
            fmt % (minor);
            path += fmt.str();
            fmt % (index + 1);
            path += "/" + fmt.str();
        }
        if (minor == 999) {
            major++;
            fmt % (major);
            path += fmt.str() + "/000";
        }
        // std::cerr << "PATH: " << path << ": /" << major << "/ " << minor << "/ " << index << std::endl;
        //planet->endTimer("change file");
    }
}

void
startStateThreads(const std::string &base, std::vector<std::string> &files)
{
    // std::map<std::string, std::thread> thread_pool;
     auto planet = std::make_shared<replication::Planet>();
    
    boost::system::error_code ec;
    // This lambda gets creates inline code for each thread in the pool
    auto state = [planet](const std::string &path)->bool {
        std::shared_ptr<replication::StateFile> state = threadStateFile(planet->stream,
                                                                        path + ".state.txt");
        if (!state->path.empty()) {
            planet->writeState(*state);
            state->dump();
            return true;
        } else {
            std::cerr << "ERROR: No StateFile returned: " << path << std::endl;
            // planet.reset(new replication::Planet);
            // planet.reset(new replication::Planet());

            // planet.connectServer();
            // std::this_thread::sleep_for(std::chrono::seconds{1});
            // state = threadStateFile(planet.stream, path + ".state.txt");
            // if (!state->path.empty()) {
            //     planet.writeState(*state);
            //     state->dump();
            //     return true;
            // }
            return false;
        }
    };

    // boost::asio::thread_pool pool(20);
    boost::asio::thread_pool pool(/* std::thread::hardware_concurrency() */ );

    // Note this uses ranges, which only got added in C++20, so
    // for now use the ranges-v3 library, which is the implementation.
    // The planet server drops the network connection after 111
    // GET requests, so break the 1000 strings into smaller chunks
    // 144, 160, 176, 192, 208, 224
    auto rng  = files | ranges::views::chunk(200);

    Timer timer;
    timer.startTimer();
    for (auto cit = std::begin(rng); cit != std::end(rng); ++cit) {
        // std::cout << "Chunk data: " << *cit << std::endl;
        for (auto it = std::begin(*cit); it != std::end(*cit); ++it) {
            if (boost::filesystem::extension(*it) != ".txt") {
                continue;
            }
            std::string subpath = base + it->substr(0, it->size() - 10);
            std::shared_ptr<replication::StateFile> exists = planet->getState(subpath);
            if (!exists->path.empty()) {
                std::cout << "Already stored: " << subpath << std::endl;
                continue;
            }
            // Add a thread to the pool for this file
            if (!it->size() <= 1) {
#ifdef USE_MULTI_LOADER
                boost::asio::post(pool, [subpath, state]{state(subpath);});
#else
                std::shared_ptr<replication::StateFile> state = threadStateFile(planet->stream,
                                                                base + *it);
                if (!state->path.empty()) {
                    planet->writeState(*state);
                    state->dump();
                    continue;
                } else {
                    std::cerr << "ERROR: No StateFile returned: " << subpath << std::endl;
                }
#endif
            }
        }
        //timer.endTimer("chunk ");
        // Don't hit the server too hard while testing, it's not polite
        // std::this_thread::sleep_for(std::chrono::seconds{1});
        planet->disconnectServer();
        planet.reset(new replication::Planet);
    }
#ifdef USE_MULTI_LOADER
    pool.join();
#endif
    planet->ioc.reset();
    // planet->stream.socket().shutdown(tcp::socket::shutdown_both, ec);
    timer.endTimer("directory ");
}

// This thread get started for every osmChange file
bool
threadOsmChange(const std::string &file)
{
    osmstats::QueryOSMStats ostats;
    replication::Planet planet;
    // changeset::ChangeSetFile change;
    osmchange::OsmChangeFile osmchanges;

    // boost::filesystem::path dir(file);
    std::string dir = file.substr(file.find("minute"));
    auto data = std::make_shared<std::vector<unsigned char>>();
    // If the file is stored on disk, read it in instead of downloading
    if (boost::filesystem::exists(dir)) {
        std::cout << "Reading osmChange: " << file << std::endl;
        // Since we want to read in the entire file so it can be
        // decompressed, blow off C++ streaming and just load the
        // entire thing.
        int size = boost::filesystem::file_size(dir);
        data->reserve(size);
        data->resize(size);
        int fd = open(dir.c_str(), O_RDONLY);
        char *buf = new char[size];
        //memset(buf, 0, size);
        read(fd, buf, size);
        // FIXME: it would be nice to avoid this copy
        std::copy(buf, buf+size, data->begin());
        close(fd);
    } else {
        std::cout << "Downloading osmChange: " << file << std::endl;
        data = planet.downloadFile(file);
    }
    if (data->size() == 0) {
        std::cout << "osmChange file not found: " << file << std::endl;
        return false;
    } else {
        // XML parsers expect every line to have a newline, including the end of file
        // data->push_back('\n');
#ifdef USE_CACHE
        if (!boost::filesystem::exists(dir)) {
            std::ofstream myfile;
            std::vector<std::string> result;
            boost::split(result, file, boost::is_any_of("/"));
            boost::filesystem::create_directory(result[4]);
            boost::filesystem::create_directory(result[4] + "/" + result[5]);
            boost::filesystem::create_directory(result[4] + "/" + result[5] + "/" + result[6]);
            myfile.open(dir, std::ios::binary);
            myfile.write(reinterpret_cast<char *>(data->data()), data->size()-1);
            myfile.close();
        }
#endif
        try {
            boost::iostreams::filtering_streambuf<boost::iostreams::input> inbuf;
            inbuf.push(boost::iostreams::gzip_decompressor());
            boost::iostreams::array_source arrs{reinterpret_cast<char const*>(data->data()), data->size()};
            inbuf.push(arrs);
            std::istream instream(&inbuf);
            try {
                osmchanges.readXML(instream);
            } catch (std::exception& e) {
                std::cerr << "ERROR: Couldn't parse: " << file << std::endl;
                std::cerr << e.what() << std::endl;
                // return false;
            }
            // change.readXML(instream);
        } catch (std::exception& e) {
            std::cerr << "ERROR: " << file << " is corrupted!" << std::endl;
            std::cerr << e.what() << std::endl;
            // return false;
        }
    }

    // Apply the changes to the database
    for (auto it = std::begin(osmchanges.changes); it != std::end(osmchanges.changes); ++it) {
        ostats.applyChange(*(*it));
    }
    ostats.disconnect();
    osmchanges.dump();
    return true;
}

// This updates several fields in the raw_changesets table, which are part of
// the changeset file, and don't need to be calculated.
//void threadChangeSet(const std::string &file, std::promise<bool> &&result)
bool
threadChangeSet(const std::string &file)
{
    //osmstats::QueryOSMStats ostats;
    replication::Planet planet;
    changeset::ChangeSetFile changeset;

    auto data = std::make_shared<std::vector<unsigned char>>();
    std::string dir = file.substr(file.find("changesets"));
    if (boost::filesystem::exists(dir)) {
        std::cout << "Reading ChangeSet: " << dir << std::endl;
        // Since we want to read in the entire file so it can be
        // decompressed, blow off C++ streaming and just load the
        // entire thing.
        int size = boost::filesystem::file_size(dir);
        data->reserve(size);
        data->resize(size);
        int fd = open(dir.c_str(), O_RDONLY);
        char *buf = new char[size];
        //memset(buf, 0, size);
        read(fd, buf, size);
        // FIXME: it would be nice to avoid this copy
        std::copy(buf, buf+size, data->begin());
        close(fd);
    } else {
        std::cout << "Downloading ChangeSet: " << file << std::endl;
        data = planet.downloadFile(file);
    }
    if (data->size() == 0) {
        std::cout << "ChangeSet file not found: " << file << std::endl;
        //result.set_value(false);
        return false;
    } else {
        //result.set_value(true);
        // XML parsers expect every line to have a newline, including the end of file
#ifdef USE_CACHE
        if (!boost::filesystem::exists(dir)) {
            std::ofstream myfile;
            std::vector<std::string> result;
            boost::split(result, file, boost::is_any_of("/"));
            boost::filesystem::create_directory(result[4]);
            boost::filesystem::create_directory(result[4] + "/" + result[5]);
            boost::filesystem::create_directory(result[4] + "/" + result[5] + "/" + result[6]);
            myfile.open(result[4] + "/" + result[5] + "/" + result[6] + "/" + result[7], std::ios::binary);
            myfile.write(reinterpret_cast<char *>(data->data()), data->size()-1);
            myfile.close();
        }
#endif
        //data->push_back('\n');
        try {
            boost::iostreams::filtering_streambuf<boost::iostreams::input> inbuf;
            inbuf.push(boost::iostreams::gzip_decompressor());
            // data->push_back('\n');
            boost::iostreams::array_source arrs{reinterpret_cast<char const*>(data->data()), data->size()};
            inbuf.push(arrs);
            std::istream instream(&inbuf);
            try {
                changeset.readXML(instream);
            } catch (std::exception& e) {
                std::cerr << "ERROR: Couldn't parse: " << file << std::endl;
                std::cerr << e.what() << std::endl;
                // return false;
            }
            // change.readXML(instream);
        } catch (std::exception& e) {
            std::cerr << "ERROR: " << file << " is corrupted!" << std::endl;
            std::cerr << e.what() << std::endl;
            // return false;
        }
    }

    // // Apply the changes to the database
    for (auto it = std::begin(changeset.changes); it != std::end(changeset.changes); ++it) {
        //ostats.applyChange(*it);
    }
    changeset.dump();
    return true;
}

// This updates the calculated fields in the raw_changesets table, based on
// the data in the OSM stats database.
void
threadStatistics(const std::string &database, ptime &timestamp)
{
    osmstats::QueryOSMStats ostats;
    replication::Replication repl;
}

// Updates the states table in the Underpass database
std::shared_ptr<replication::StateFile>
threadStateFile(ssl::stream<tcp::socket> &stream, const std::string &file)
{
    std::string server = "planet.openstreetmap.org";
    // See if the data exists in the database already
    // std::shared_ptr<replication::StateFile> exists = planet.getState(subpath);    

    // This buffer is used for reading and must be persistant
    boost::beast::flat_buffer buffer;
    boost::beast::error_code ec;

    // Set up an HTTP GET request message
    http::request<http::string_body> req{http::verb::get, file, 11};

    req.keep_alive();
    req.set(http::field::host, server);
    req.set(http::field::user_agent, BOOST_BEAST_VERSION_STRING);
    
    // std::cout << "(" << std::this_thread::get_id() << ")Downloading " << file << std::endl;

    // Stays locked till the function exits
    const std::lock_guard<std::mutex> lock(stream_mutex);

    // Send the HTTP request to the remote host
    // std::lock_guard<std::mutex> guard(stream_mutex);
    boost::beast::http::response_parser<http::string_body> parser;

    http::write(stream, req);
    boost::beast::http::read(stream, buffer, parser, ec);
    if (ec == http::error::partial_message) {
        std::cerr << "ERROR: partial read" << ": " << ec.message() << std::endl;
        // Give the network a chance to recover
        std::this_thread::yield();
        // std::this_thread::sleep_for(std::chrono::seconds{1});
        //return std::make_shared<replication::StateFile>();
    }
    if (ec == http::error::end_of_stream) {
        std::cerr << "ERROR: end of stream read failed" << ": " << ec.message() << std::endl;
        // Give the network a chance to recover
        // stream.socket().shutdown(tcp::socket::shutdown_both, ec);
        return std::make_shared<replication::StateFile>();
    } else if (ec) {
        std::cerr << "ERROR: stream read failed" << ": " << ec.message() << std::endl;
        return std::make_shared<replication::StateFile>();
    }
    if (parser.get().result() == boost::beast::http::status::not_found) {
        // continue;
    }

    // File never downloaded, return empty
    if (parser.get().body().size() < 10) {
        std::cerr << "ERROR: failed to download:  " << ": " << file << std::endl;
        return std::make_shared<replication::StateFile>();
    }

    //const std::lock_guard<std::mutex> unlock(stream_mutex);
    auto data = std::make_shared<std::vector<unsigned char>>();
    for (auto body = std::begin(parser.get().body()); body != std::end(parser.get().body()); ++body) {
        data->push_back((unsigned char)*body);
    }
    if (data->size() == 0) {
        std::cout << "StateFile not found: " << file << std::endl;
        return std::make_shared<replication::StateFile>();
    } else {
        std::string tmp(reinterpret_cast<const char *>(data->data()));
        auto state = std::make_shared<replication::StateFile>(tmp, true);
        if (!file.empty()) {
            state->path = file.substr(0, file.size() - 10);
        }
        return state;
    }
}

}       // EOF namespace threads

