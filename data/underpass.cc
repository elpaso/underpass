//
// Copyright (c) 2020, 2021 Humanitarian OpenStreetMap Team
//
// This file is part of Underpass.
//
//     Underpass is free software: you can redistribute it and/or modify
//     it under the terms of the GNU General Public License as published by
//     the Free Software Foundation, either version 3 of the License, or
//     (at your option) any later version.
//
//     Underpass is distributed in the hope that it will be useful,
//     but WITHOUT ANY WARRANTY; without even the implied warranty of
//     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//     GNU General Public License for more details.
//
//     You should have received a copy of the GNU General Public License
//     along with Underpass.  If not, see <https://www.gnu.org/licenses/>.
//

// This is generated by autoconf
#ifdef HAVE_CONFIG_H
#include "unconfig.h"
#endif

#include <algorithm>
#include <cstdlib>
#include <cstring>
#include <exception>
#include <filesystem>
#include <iostream>
#include <string>
#include <utility>
#include <vector>

#include "boost/date_time/posix_time/posix_time.hpp"
#include <boost/date_time.hpp>
#include <boost/format.hpp>
using namespace boost::posix_time;
using namespace boost::gregorian;
//#include <boost/tokenizer.hpp>
#include <boost/filesystem.hpp>

#include "data/underpass.hh"
#include "osmstats/changeset.hh"
#include "osmstats/osmchange.hh"
#include "osmstats/replication.hh"

#include "log.hh"
using namespace logger;

namespace underpass {

std::map<replication::frequency_t, std::string> Underpass::frequency_tags = {
    {replication::minutely, "minute"},
    {replication::hourly, "hour"},
    {replication::daily, "day"},
    {replication::changeset, "changeset"}};

Underpass::Underpass(const std::string &dburl) { connect(dburl); };

Underpass::~Underpass(void)
{
    // db->disconnect();        // close the database connection
    if (sdb) {
        if (sdb->is_open()) {
            sdb->close(); // close the database connection
        }
    }
}

// Dump internal data to the terminal, used only for debugging
void
Underpass::dump(void)
{
    log_debug(_("Database url: %1%"), db_url);
}

std::shared_ptr<replication::StateFile>
Underpass::getState(replication::frequency_t freq, const std::string &path)
{
    auto state = std::make_shared<replication::StateFile>();
    if (sdb == 0) {
        log_error(_("database not connected!"));
        return state;
    } else if (!sdb->is_open()) {
        log_error(_("database not open!!"));
        return state;
    }
    std::vector<std::string> nodes;
    std::string tmp;
    boost::split(nodes, path, boost::is_any_of("/"));
    if (nodes[0] == "https:") {
        tmp = nodes[5] + "/" + nodes[6] + "/" + nodes[7];
    } else {
        tmp = path;
    }
    //db_mutex.lock();
    std::string query =
        "SELECT timestamp,path,sequence,frequency FROM states WHERE path=\'";
    query += tmp + "\' AND frequency=\'" + frequency_tags[freq] + "\'";
    log_debug(_("QUERY: %1%"), query);
    pqxx::work worker(*sdb);
    pqxx::result result = worker.exec(query);
    worker.commit();
    if (result.size() > 0) {
        state->timestamp = time_from_string(pqxx::to_string(result[0][0]));
        state->path = pqxx::to_string(result[0][1]);
        state->sequence = result[0][2].as(int(0));
        state->frequency = pqxx::to_string(result[0][3]);
    }
    //db_mutex.unlock();
    return state;
}

// Get the state.txt date by timestamp
std::shared_ptr<replication::StateFile>
Underpass::getState(replication::frequency_t freq, ptime &tstamp)
{
    auto state = std::make_shared<replication::StateFile>();
    if (tstamp == boost::posix_time::not_a_date_time) {
        log_error(_("ERROR: bad timestamp!"));
        exit(1);
    }

    if (sdb > 0) {
        if (!sdb->is_open()) {
            log_error(_("database not connected!"));
            return state;
        }
    } else {
        log_error(_("database not connected!"));
        return state;
    }

    ptime other = tstamp + minutes(1);
    std::string query = "SELECT timestamp,path,created_at,closed_at FROM "
                        "states WHERE timestamp BETWEEN ";
    query += "\'" + to_simple_string(tstamp) + "\' AND ";
    query += "\'" + to_simple_string(other) + "\' ";
    query += " AND frequency=";
    query += "\'" + frequency_tags[freq] + "\'";
    query += " ORDER BY timestamp ASC LIMIT 1;";
    log_debug(_("QUERY: %1%"), query);
    pqxx::work worker(*sdb);
    pqxx::result result = worker.exec(query);
    worker.commit();
    if (result.size() > 0) {
        // Sometimes these two fields are reversed
        try {
            state->timestamp = time_from_string(result[0][0].c_str());
            state->path = pqxx::to_string(result[0][1]);
        } catch (std::exception &e) {
            log_error(_("Couldn't parse StateFile %1%"), e.what());
            state->path = pqxx::to_string(result[0][0]);
            state->timestamp = time_from_string(result[0][1].c_str());
            state->created_at = time_from_string(pqxx::to_string(result[0][2]));
            state->closed_at = time_from_string(pqxx::to_string(result[0][3]));
        }
        state->sequence = result[0][2].as(int(0));
        state->frequency = freq;
    } else {
#if 0
        // FIXME: this does not work yet
        ptime start = time_from_string("2012-09-12 13:22");
        boost::posix_time::time_duration delta = tstamp - start;
        state->timestamp = tstamp;
        state->sequence = 0;
        state->path = "https://planet.openstreetmap.org/replication";
        state->path += "\'" + frequency_tags[freq] + "\'";
        boost::format fmt("%03d");
        int next;
        fmt % (next);
        state->path += fmt.str();
#endif
    }
    return state;
}

std::shared_ptr<replication::StateFile>
Underpass::getState(replication::frequency_t freq, long sequence)
{
    auto state = std::make_shared<replication::StateFile>();
    if (sdb == 0) {
        log_error(_("database not connected!"));
        return state;
    } else if (!sdb->is_open()) {
        log_error(_("database not open!!"));
        return state;
    }

    pqxx::work worker(*sdb);

    const std::string sql{"SELECT timestamp,path,created_at,closed_at FROM "
                          "states WHERE sequence = " +
                          std::to_string(sequence) + " AND frequency = " +
                          worker.quote(Underpass::freq_to_string(freq)) +
                          " LIMIT 1"};

    const auto result{worker.exec(sql)};
    if (result.size() == 1) {
        state->timestamp = time_from_string(pqxx::to_string(result[0][0]));
        state->path = pqxx::to_string(result[0][1]);
        state->sequence = result[0][2].as(int(0));
        state->frequency = Underpass::freq_to_string(freq);
        auto datetime_str{pqxx::to_string(result[0][4])};
        if (!datetime_str.empty()) {
            state->created_at = time_from_string(datetime_str);
        }
        datetime_str = pqxx::to_string(result[0][5]);
        if (!datetime_str.empty()) {
            state->closed_at = time_from_string(datetime_str);
        }
    }
    worker.commit();

    return state;
}

/// Write the stored data on the directories and timestamps
/// on the planet server.
bool
Underpass::writeState(replication::StateFile &state)
{
    std::string query;
    pqxx::work worker(*sdb);

    if (state.created_at != boost::posix_time::not_a_date_time) {
        query = "INSERT INTO states(timestamp, sequence, path, frequency, "
                "created_at, closed_at) VALUES(";
    } else {
        query =
            "INSERT INTO states(timestamp, sequence, path, frequency) VALUES(";
    }
    query += "\'" + to_iso_extended_string(state.timestamp) + "\',";
    query += std::to_string(state.sequence);
    std::vector<std::string> nodes;
    boost::split(nodes, state.path, boost::is_any_of("/"));
    std::string tmp;
    if (nodes[0] == "https:") {
        tmp = nodes[5] + '/' + nodes[6] + '/' + nodes[7];
    } else {
        tmp = state.path;
    }

    query += ",\'" + tmp + "\'";

    // Deduce the frequency from the path is it's not explicitly set
    std::string frequency{state.frequency};
    if (frequency.empty()) {

        if (state.path.find("changeset") != std::string::npos) {
            frequency = "changeset";
        } else if (state.path.find("minute") != std::string::npos) {
            frequency = "minute";
        } else if (state.path.find("hour") != std::string::npos) {
            frequency = "hour";
        } else if (state.path.find("day") != std::string::npos) {
            frequency = "day";
        }
    }

    query += ", " + worker.quote(frequency);

    if (state.created_at != boost::posix_time::not_a_date_time) {
        query += ", \'" + to_simple_string(state.created_at) + "\'";
        query += ", \'" + to_simple_string(state.closed_at) + "\'";
    }
    query += ") ON CONFLICT DO NOTHING;";
    log_debug(query);
    //db_mutex.lock();
    try {
        const auto result = worker.exec(query);
        worker.commit();
    } catch (pqxx::sql_error const &ex) {
        log_error(_("Error storing state in the DB: %1%"), ex.what());
        return false;
    }
    return true;
}

/// Get the maximum timestamp for the state.txt data
std::shared_ptr<replication::StateFile>
Underpass::getLastState(replication::frequency_t freq)
{
    pqxx::work worker(*sdb);
    //    std::string query = "SELECT timestamp,sequence,path,frequency,created_at,closed_at FROM states";
    std::string query = "SELECT timestamp,sequence,path FROM states";
    query += " WHERE frequency=";
    if (freq == replication::changeset) {
        query += "\'changeset\'";
    } else if (freq == replication::minutely) {
        query += "\'minute\'";
    } else if (freq == replication::hourly) {
        query += "\'hour\'";
    } else if (freq == replication::daily) {
        query += "\'day\'";
    }
    query += " ORDER BY timestamp DESC LIMIT 1;";
    log_debug(_("QUERY: %1%"), query);
    pqxx::result result = worker.exec(query);
    auto last = std::make_shared<replication::StateFile>();
    if (result.size() > 0) {
        last->timestamp = time_from_string(pqxx::to_string(result[0][0]));
        last->sequence = result[0][1].as(int(0));
        last->path = pqxx::to_string(result[0][2]);
        last->frequency = freq;
        //last->created_at = time_from_string(pqxx::to_string(result[0][3]));
        //last->closed_at = time_from_string(pqxx::to_string(result[0][4]));
    }

    worker.commit();

    return last;
}

// Get the minimum timestamp for the state.txt data. As hashtags didn't
// appear until late 2014, we don't care as much about the older data.
std::shared_ptr<replication::StateFile>
Underpass::getFirstState(replication::frequency_t freq)
{
    pqxx::work worker(*sdb);
    std::string query = "SELECT timestamp,sequence,path FROM states ORDER BY "
                        "timestamp ASC LIMIT 1;";
    // log_debug(_("QUERY: %1%", query);
    pqxx::result result = worker.exec(query);
    auto first = std::make_shared<replication::StateFile>();
    if (result.size() > 0) {
        first->timestamp = time_from_string(pqxx::to_string(result[0][0]));
        first->sequence = result[0][1].as(int(0));
        first->path = pqxx::to_string(result[0][2]);
        first->frequency = freq;
        // first->created_at = time_from_string(pqxx::to_string(result[0][3]));
        // first->closed_at = time_from_string(pqxx::to_string(result[0][4]));
    } else {
        log_error(
            _("Error retrieving first state from DB: states table is empty."));
    }

    worker.commit();

    return first;
}

} // namespace underpass
