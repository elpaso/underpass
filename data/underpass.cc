//
// Copyright (c) 2020, 2021 Humanitarian OpenStreetMap Team
//
// This file is part of Underpass.
//
//     Underpass is free software: you can redistribute it and/or modify
//     it under the terms of the GNU General Public License as published by
//     the Free Software Foundation, either version 3 of the License, or
//     (at your option) any later version.
//
//     Underpass is distributed in the hope that it will be useful,
//     but WITHOUT ANY WARRANTY; without even the implied warranty of
//     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//     GNU General Public License for more details.
//
//     You should have received a copy of the GNU General Public License
//     along with Underpass.  If not, see <https://www.gnu.org/licenses/>.
//

// This is generated by autoconf
#ifdef HAVE_CONFIG_H
# include "unconfig.h"
#endif

#include <string>
#include <vector>
#include <filesystem>
#include <iostream>
#include <cstdlib>
#include <cstring>
#include <exception>
#include <algorithm>
#include <utility>

#include <boost/format.hpp>
#include <boost/date_time.hpp>
#include "boost/date_time/posix_time/posix_time.hpp"
using namespace boost::posix_time;
using namespace boost::gregorian;
//#include <boost/tokenizer.hpp>
#include <boost/filesystem.hpp>

#include "osmstats/replication.hh"
#include "osmstats/changeset.hh"
#include "osmstats/osmchange.hh"
#include "data/underpass.hh"

#include "log.hh"
using namespace logger;

namespace underpass {

// logger::LogFile& dbglogfile = logger::LogFile::getDefaultInstance();
// Underpass::Underpass(void)
// {
//     frequency_tags[replication::minutely] = "minute";
//     frequency_tags[replication::hourly] = "hour";
//     frequency_tags[replication::daily] = "day";
//     frequency_tags[replication::changeset] = "changeset";
// }

Underpass::Underpass(const std::string &dbname)
{
    if (dbname.empty()) {
        // Validate environment variable is defined.
        char *tmp = std::getenv("UNDERPASS_DB_URL");
        db_url = tmp;
    } else {
        db_url = "dbname = " + dbname;
    }
    connect(dbname);
};

Underpass::~Underpass(void)
{
    // db->disconnect();        // close the database connection
    if (sdb) {
        if (sdb->is_open()) {
            sdb->close();            // close the database connection
        }
    }
}

// Dump internal data to the terminal, used only for debugging
void
Underpass::dump(void)
{
    log_debug(_("Database url: %1%"), db_url);
}

bool
Underpass::connect(void)
{
    return connect("underpass");
}

bool
Underpass::connect(const std::string &dburl)
{
    if (dburl.empty()) {
	log_error(_(" need to specify URL connection string!"));
    }

    std::string dbuser;
    std::string dbpass;
    std::string dbhost;
    std::string dbname = "dbname=";
    std::size_t apos = dburl.find('@');
    if (apos != std::string::npos) {
	dbuser = "user=";
	std::size_t cpos = dburl.find(':');
	if (cpos != std::string::npos) {
	    dbuser += dburl.substr(0, cpos);
	    dbpass = "password=";
	    dbpass += dburl.substr(cpos+1, apos-cpos-1);
	} else {
	    dbuser += dburl.substr(0, apos);
	}
    }

    std::vector<std::string> result;
    if (apos != std::string::npos) {
	boost::split(result, dburl.substr(apos+1), boost::is_any_of("/"));
    } else {
	boost::split(result, dburl, boost::is_any_of("/"));
    }
    if (result.size() == 1) {
	dbname += result[0];
	dbhost = "host=localhost";
    } else if (result.size() == 2) {
	if (result[0] != "localhost") {
	    dbhost = "host=";
	    dbhost += result[0];
	}
	dbname += result[1];
    }
    std::string args = dbhost + " " + dbname + " " + dbuser + " " + dbpass;
    // log_debug(args);
    try {
	sdb = std::make_shared<pqxx::connection>(args);
	if (sdb->is_open()) {
            log_debug(_("Opened database connection to %1%"), dburl);
	    return true;
	} else {
	    return false;
	}
    } catch (const std::exception &e) {
	log_error(_(" Couldn't open database connection to %1% %2%"), dburl, e.what());
	return false;
   }    
}

std::shared_ptr<replication::StateFile>
Underpass::getState(replication::frequency_t freq, const std::string &path)
{
    auto state = std::make_shared<replication::StateFile>();
    if (!sdb->is_open()) {
        log_error(_("database not connected!"));
        return state;
    }
    std::vector<std::string> nodes;
    std::string tmp;
    boost::split(nodes, path, boost::is_any_of("/"));
    if (nodes[0] == "https:") {
        tmp = nodes[5] + "/" + nodes[6] + "/" + nodes[7];
    } else {
        tmp = path;
    }
    //db_mutex.lock();
    std::string query = "SELECT timestamp,path,sequence,frequency FROM states WHERE path=\'";
    query += tmp + "\' AND frequency=\'" + frequency_tags[freq] + "\'";
    log_debug(_("QUERY: %1%"), query);
    pqxx::work worker(*sdb);
    pqxx::result result = worker.exec(query);
    worker.commit();
    if (result.size() > 0) {
        state->timestamp = time_from_string(pqxx::to_string(result[0][0]));
        state->path = pqxx::to_string(result[0][1]);
        state->sequence = result[0][2].as(int(0));
        state->frequency =  pqxx::to_string(result[0][3]);
    }
    //db_mutex.unlock();
    return state;
}

// Get the state.txt date by timestamp
std::shared_ptr<replication::StateFile>
Underpass::getState(replication::frequency_t freq, ptime &tstamp)
{
    auto state = std::make_shared<replication::StateFile>();
    if (tstamp == boost::posix_time::not_a_date_time) {
        log_error(_("ERROR: bad timestamp!"));
        exit(1);
    }
    
    if (sdb > 0) {
        if (!sdb->is_open()) {
            log_error(_("database not connected!"));
            return state;
        }
    } else {
        log_error(_("database not connected!"));
        return state;
    }

    ptime other = tstamp + minutes(1);
    std::string query = "SELECT timestamp,path,created_at,closed_at FROM states WHERE timestamp BETWEEN ";
    query += "\'" + to_simple_string(tstamp) + "\' AND ";
    query += "\'" + to_simple_string(other) + "\' ";
    query += " AND frequency=";
    query += "\'" + frequency_tags[freq] + "\'";
    query += " ORDER BY timestamp ASC LIMIT 1;";
    log_debug(_("QUERY: %1%"), query);
    pqxx::work worker(*sdb);
    pqxx::result result = worker.exec(query);
    worker.commit();
    if (result.size() > 0) {
        // Sometimes these two fields are reversed
        try {
            state->timestamp = time_from_string(result[0][0].c_str());
            state->path = pqxx::to_string(result[0][1]);
        } catch (std::exception& e) {
            log_error(_("Couldn't parse StateFile %1%"), e.what());
            state->path = pqxx::to_string(result[0][0]);
            state->timestamp = time_from_string(result[0][1].c_str());
            state->created_at = time_from_string(pqxx::to_string(result[0][2]));
            state->closed_at = time_from_string(pqxx::to_string(result[0][3]));
        }
        state->sequence = result[0][2].as(int(0));
        state->frequency = freq;
    } else {
#if 0
        // FIXME: this does not work yet
        ptime start = time_from_string("2012-09-12 13:22");
        boost::posix_time::time_duration delta = tstamp - start;
        state->timestamp = tstamp;
        state->sequence = 0;
        state->path = "https://planet.openstreetmap.org/replication";
        state->path += "\'" + frequency_tags[freq] + "\'";
        boost::format fmt("%03d");
        int next;
        fmt % (next);
        state->path += fmt.str();
#endif
    }
    return state;
}

/// Write the stored data on the directories and timestamps
/// on the planet server.
bool
Underpass::writeState(replication::StateFile &state)
{
    std::string query;

    if (state.created_at != boost::posix_time::not_a_date_time) {
        query = "INSERT INTO states(timestamp, sequence, path, frequency, created_at, closed_at) VALUES(";
    } else {
        query = "INSERT INTO states(timestamp, sequence, path, frequency) VALUES(";
    }
    query += "\'" + to_simple_string(state.timestamp) + "\',";
    query += std::to_string(state.sequence);
    std::vector<std::string> nodes;
    boost::split(nodes, state.path, boost::is_any_of("/"));
    std::string tmp;
    if (nodes[0] == "https:") {
        tmp = nodes[5] + '/' + nodes[6] + '/' + nodes[7];
    } else {
        tmp = state.path;
    }
    
    query += ",\'" + tmp + "\'";
    if (state.path.find("changeset") != std::string::npos) {
        query += ", \'changeset\'";
    } else if (state.path.find("minute") != std::string::npos) {
        query += ", \'minute\'";
    } else if (state.path.find("hour") != std::string::npos) {
        query += ", \'hour\'";
    } else if (state.path.find("day") != std::string::npos) {
        query += ", \'day\'";
    }
    if (state.created_at != boost::posix_time::not_a_date_time) {
        query += ", \'" + to_simple_string(state.created_at) + "\'";
        query += ", \'" + to_simple_string(state.closed_at) + "\'";
    }
    query += ") ON CONFLICT DO NOTHING;";
    // log_debug(_("QUERY: " << query);
    //db_mutex.lock();
    pqxx::work worker(*sdb);
    pqxx::result result = worker.exec(query);
    worker.commit();

    return false;
}

/// Get the maximum timestamp for the state.txt data
std::shared_ptr<replication::StateFile>
Underpass::getLastState(replication::frequency_t freq)
{
    pqxx::work worker(*sdb);
//    std::string query = "SELECT timestamp,sequence,path,frequency,created_at,closed_at FROM states";
    std::string query = "SELECT timestamp,sequence,path FROM states";
    query += " WHERE frequency=";
    if (freq == replication::changeset) {
        query += "\'changeset\'";
    } else if (freq == replication::minutely) {
        query += "\'minute\'";
    } else if (freq == replication::hourly) {
        query += "\'hour\'";
    } else if (freq == replication::daily) {
        query += "\'day\'";
    }
    query +=" ORDER BY timestamp DESC LIMIT 1;";
    log_debug(_("QUERY: %1%"), query);
    pqxx::result result = worker.exec(query);
    auto last = std::make_shared<replication::StateFile>();
    if (result.size() > 0) {
        last->timestamp = time_from_string(pqxx::to_string(result[0][0]));
        last->sequence = result[0][1].as(int(0));
        last->path = pqxx::to_string(result[0][2]);
        last->frequency = freq;
        //last->created_at = time_from_string(pqxx::to_string(result[0][3]));
        //last->closed_at = time_from_string(pqxx::to_string(result[0][4]));
    }

    worker.commit();

    return last;
}

// Get the minimum timestamp for the state.txt data. As hashtags didn't
// appear until late 2014, we don't care as much about the older data.
std::shared_ptr<replication::StateFile>
Underpass::getFirstState(replication::frequency_t freq)
{
    pqxx::work worker(*sdb);
    std::string query = "SELECT timestamp,sequence,path FROM states ORDER BY timestamp ASC LIMIT 1;";
    // log_debug(_("QUERY: %1%", query);
    pqxx::result result = worker.exec(query);
    auto first = std::make_shared<replication::StateFile>();
    first->timestamp = time_from_string(pqxx::to_string(result[0][0]));
    first->sequence = result[0][1].as(int(0));
    first->path = pqxx::to_string(result[0][2]);
    first->frequency = freq;
    // first->created_at = time_from_string(pqxx::to_string(result[0][3]));
    // first->closed_at = time_from_string(pqxx::to_string(result[0][4]));

    worker.commit();

    return first;
}

} // EOF replication namespace

