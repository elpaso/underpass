//
// Copyright (c) 2020, Humanitarian OpenStreetMap Team
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
// * Redistributions of source code must retain the above copyright notice, this
//   list of conditions and the following disclaimer.
//
// * Redistributions in binary form must reproduce the above copyright notice,
//   this list of conditions and the following disclaimer in the documentation
//   and/or other materials provided with the distribution.
//
// * Neither the name of copyright holder nor the names of its
//   contributors may be used to endorse or promote products derived from
//   this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//

// This is generated by autoconf
#ifdef HAVE_CONFIG_H
# include "hotconfig.h"
#endif

#include <string>
#include <vector>
#include <array>
#include <memory>
#include <iostream>
#include <pqxx/pqxx>
#include <cstdlib>
#include <cstring>
#include <exception>
#include <utility>
#include <fstream>
#include <sstream>
#include <filesystem>
#include <deque>
#include <list>
#include <zlib.h>
#ifdef LIBXML
#  include <libxml++/libxml++.h>
#endif 

#include <osmium/io/any_input.hpp>
#include <osmium/builder/osm_object_builder.hpp>
#include <osmium/handler.hpp>
#include <osmium/visitor.hpp>
#include <osmium/io/any_output.hpp>
#include <glibmm/convert.h>

#include <boost/foreach.hpp>
#include <boost/date_time.hpp>
#include "boost/date_time/posix_time/posix_time.hpp"
using namespace boost::posix_time;
using namespace boost::gregorian;
#include <boost/iostreams/filtering_streambuf.hpp>
#include <boost/iostreams/copy.hpp>
#include <boost/filesystem.hpp>
#include <boost/iostreams/filter/gzip.hpp>
#include <boost/iostreams/device/array.hpp>
#include <boost/iostreams/device/back_inserter.hpp>
#include <boost/iostreams/filtering_stream.hpp>
#include <boost/property_tree/xml_parser.hpp>
#include <boost/property_tree/ptree.hpp>

#include "hotosm.hh"
#include "osmstats/osmstats.hh"
#include "osmstats/changeset.hh"

#define BOOST_BIND_GLOBAL_PLACEHOLDERS 1

namespace changeset {

/// parse the two state file for a replication file, from
/// disk or memory.

// There are two types of state files with of course different
// formats for the same basic data. The simplest one is for
// changesets, which looks like this:
// ---
// last_run: 2020-10-08 22:30:01.737719000 +00:00
// sequence: 4139992
//
// The other format is used for minutely change files, and
// has mnore fields. For now, only the timestamp and sequence
// number is stored. It looks like this:
// #Fri Oct 09 10:03:04 UTC 2020
// sequenceNumber=4230996
// txnMaxQueried=3083073477
// txnActiveList=
// txnReadyList=
// txnMax=3083073477
// timestamp=2020-10-09T10\:03\:02Z
//
// State files are used to know where to start downloading files
StateFile::StateFile(const std::string &file, bool memory)
{
    std::string line;
    std::ifstream state;
    std::stringstream ss;

    // It's a disk file, so read it in.
    if (!memory) {
        try {
            state.open(file, std::ifstream::in);
        }
        catch(std::exception& e) {
            std::cout << "ERROR opening " << file << std::endl;
            std::cout << e.what() << std::endl;
            // return false;
        }
        // For a disk file, none of the state files appears to be larger than
        // 70 bytes, so read the whole thing into memory without
        // any iostream buffering.
        std::filesystem::path path = file;
        int size = std::filesystem::file_size(path);
        char *buffer = new char[size];
        state.read(buffer, size);
        ss << buffer;
        // FIXME: We do it this way to save lots of extra buffering
        // ss.rdbuf()->pubsetbuf(&buffer[0], size);
    } else {
        // It's in memory
        ss << file;
    }

    // Get the first line
    std::getline(ss, line, '\n');

    // This is a changeset state.txt file
    if (line == "---") {
        // Second line is the last_run timestamp
        std::getline(ss, line, '\n');
        // The timestamp is the second field
        std::size_t pos = line.find(" ");
        // 2020-10-08 22:30:01.737719000 +00:00
        timestamp = time_from_string(line.substr(pos+1));

        // Third and last line is the sequence number
        std::getline(ss, line, '\n');
        pos = line.find(" ");
        // The sequence is the second field
        sequence = std::stol(line.substr(pos+1));
        // This is a change file state.txt file
    } else {
        std::getline(ss, line, '\n'); // sequenceNumber
        std::size_t pos = line.find("=");
        sequence= std::stol(line.substr(pos+1));
        std::getline(ss, line, '\n'); // txnMaxQueried
        std::getline(ss, line, '\n'); // txnActiveList
        std::getline(ss, line, '\n'); // txnReadyList
        std::getline(ss, line, '\n'); // txnMax
        std::getline(ss, line, '\n');
        pos = line.find("=");
        // The time stamp is in ISO format, ie... 2020-10-09T10\:03\:02
        // But we have to unescape the colon or boost chokes.
        std::string tmp = line.substr(pos+1);
        pos = tmp.find('\\', pos+1);
        std::string tstamp = tmp.substr(0, pos); // get the date and the hour
        tstamp += tmp.substr(pos+1, 3); // get minutes
        pos = tmp.find('\\', pos+1);
        tstamp += tmp.substr(pos+1, 3); // get seconds
        timestamp = from_iso_extended_string(tstamp);
    }

    state.close();
}

// Read a changeset file from disk, which may be a huge file
// Since it is a huge file, process in pieces and don't store
// anything except in the database
bool
ChangeSetFile::importChanges(const std::string &file)
{
    std::ifstream change;
    int size = 0;
//    store = false;

#ifdef LIBXML
    // FIXME: this should really use CHUNKS, since the files can
    // many gigs.
    try {
        set_substitute_entities(true);
        parse_file(file);
    }
    catch(const xmlpp::exception& ex) {
        std::cerr << "libxml++ exception: " << ex.what() << std::endl;
        int return_code = EXIT_FAILURE;
    }
#endif

    osmstats::QueryOSMStats ostats;
    ostats.connect("mystats");  // FIXME: debugging hack!
    for (auto it = std::begin(changes); it != std::end(changes); ++it) {
        ostats.applyChange(*it);
    }

    change.close();
    // FIXME: return real value
    return false;
}

bool
ChangeSetFile::readChanges(const std::vector<unsigned char> &buffer)
{
    
    //parse_memory((const Glib::ustring &)buffer);
}

// Read a changeset file from disk or memory into internal storage
bool
ChangeSetFile::readChanges(const std::string &file)
{
    std::ifstream change;
    int size = 0;
//    store = false;
    
    unsigned char *buffer;
    std::cout << "Reading changeset file " << file << std::endl;
    std::string suffix = boost::filesystem::extension(file);
    // It's a gzipped file, common for files downloaded from planet
    std::ifstream ifile(file, std::ios_base::in | std::ios_base::binary);
    if (suffix == ".gz") {  // it's a compressed file
        change.open(file,  std::ifstream::in |  std::ifstream::binary);
        try {
            boost::iostreams::filtering_streambuf<boost::iostreams::input> inbuf;
            inbuf.push(boost::iostreams::gzip_decompressor());
            inbuf.push(ifile);
            std::istream instream(&inbuf);
            // std::cout << instream.rdbuf();
            readXML(instream);
        } catch(std::exception& e) {
            std::cout << "ERROR opening " << file << std::endl;
            std::cout << e.what() << std::endl;
            // return false;
        }
    } else {                // it's a text file
        change.open(file, std::ifstream::in);
        readXML(change);
    }

    // magic number: 0x8b1f or 0x1f8b for gzipped
    // <?xml for text
    std::string foo = "Hello World";
    boost::iostreams::array_source(foo.c_str(), foo.size());
    // boost::iostreams::filtering_streambuf<boost::iostreams::input> fooby(foo, 10);
    
    change.close();
}

void
ChangeSet::dump(void)
{
    std::cout << "-------------------------" << std::endl;
    std::cout << "Change ID: " << id << std::endl;
    std::cout << "Created:     " << to_simple_string(created_at)  << std::endl;
    std::cout << "Closed:      " << to_simple_string(closed_at) << std::endl;
    if (open) {
        std::cout << "Open change: true" << std::endl;
    } else {
        std::cout << "Open change: false" << std::endl;
    }
    std::cout << "User:        " << user<< std::endl;
    std::cout << "User ID:     " << uid << std::endl;
    std::cout << "Min Lat:     " << min_lat << std::endl;
    std::cout << "Min Lon:     " << min_lon << std::endl;
    std::cout << "Max Lat:     " << max_lat << std::endl;
    std::cout << "Max Lon:     " << max_lon << std::endl;
    std::cout << "Changes:     " << num_changes << std::endl;
    // std::cout << "Comments:    " << comments_count << std::endl;
    for (auto it = std::begin(hashtags); it != std::end(hashtags); ++it) {
        std::cout << "Hashtags:    " << *it <<  std::endl;
    }
    if (!comment.empty()) {
        std::cout << "Comments:    " << comment << std::endl;
    }
    std::cout << "Editor:      " << editor << std::endl;
}

#ifdef LIBXML
ChangeSet::ChangeSet(const std::deque<xmlpp::SaxParser::Attribute> attributes)
{
    for(const auto& attr_pair : attributes) {
        try {
            if (attr_pair.name == "id") {
                id = std::stol(attr_pair.value);   // id
                if (id == 232) {
                    int a = 0;
                }
            } else if (attr_pair.name == "created_at") {
                created_at = from_iso_extended_string(attr_pair.value.substr(0,18));
            } else if (attr_pair.name == "closed_at") {
                closed_at = from_iso_extended_string(attr_pair.value.substr(0,18));
            } else if (attr_pair.name == "open") {
                if (attr_pair.value == "true") {
                    open = true;
                } else {
                    open = false;
                }
            } else if (attr_pair.name == "user") {
                user = attr_pair.value;
            } else if (attr_pair.name == "uid") {
                uid = std::stol(attr_pair.value);
            } else if (attr_pair.name == "min_lat") {
                min_lat = std::stod(attr_pair.value);
            } else if (attr_pair.name == "max_lat") {
                max_lat = std::stod(attr_pair.value);
            } else if (attr_pair.name == "min_lon") {
                min_lon = std::stod(attr_pair.value);
            } else if (attr_pair.name == "max_lon") {
                max_lon = std::stod(attr_pair.value);
            } else if (attr_pair.name == "num_changes") {
                num_changes = std::stoi(attr_pair.value);
            } else if (attr_pair.name == "comments_count") {
            }
        } catch(const Glib::ConvertError& ex) {
            std::cerr << "ChangeSet::ChangeSet(): Exception caught while converting values for std::cout: " << ex.what() << std::endl;
            }
    }
}
#endif  // EOF LIBXML

void
ChangeSetFile::dump(void)
{
    std::cout << "There are " << changes.size() << " changes" << std::endl;
    for (auto it = std::begin(changes); it != std::end(changes); ++it) {
        it->dump();
    }
}

// Read an istream of the data and parse the XML
//
bool
ChangeSetFile::readXML(std::istream &xml)
{
    // std::cout << xml.rdbuf();
#ifdef LIBXML
    // libxml calls on_element_start for each node, using a SAX parser,
    // and works well for large files.
    try {
        set_substitute_entities(true);
        parse_stream(xml);
    }
    catch(const xmlpp::exception& ex) {
        std::cerr << "libxml++ exception: " << ex.what() << std::endl;
        int return_code = EXIT_FAILURE;
    }
#else
    // Boost::parser_tree with RapidXML is faster, but builds a DOM tree
    // so loads the entire file into memory. Most replication files for
    // hourly or minutely changes are small, so this is better for that
    // case.
    boost::property_tree::ptree pt;
    boost::property_tree::read_xml(xml, pt);

    if (pt.empty()) {
        std::cerr << "ERROR: XML data is empty!" << std::endl;
        return false;
    }

    
    for (auto value: pt.get_child("osm")) {
        if (value.first == "changeset") {
            changeset::ChangeSet change;
            // Process the tags. These don't exist for every element
            for (auto tag: value.second) {
                if (tag.first == "tag") {
                    std::string key = tag.second.get("<xmlattr>.k", "");
                    std::string val = tag.second.get("<xmlattr>.v", "");
                    change.tags[key] = val;
                }
            }
            // Process the attributes, which do exist in every element
            change.id = value.second.get("<xmlattr>.id", 0);
            change.created_at = value.second.get("<xmlattr>.created_at",
                          boost::posix_time::second_clock::local_time());
            change.closed_at = value.second.get("<xmlattr>.closed_at",
                          boost::posix_time::second_clock::local_time());
            change.open = value.second.get("<xmlattr>.open", false);
            change.user = value.second.get("<xmlattr>.user", "");
            change.uid = value.second.get("<xmlattr>.uid", 0);
            change.min_lat = value.second.get("<xmlattr>.min_lat", 0.0);
            change.min_lon = value.second.get("<xmlattr>.min_lon", 0.0);
            change.max_lat = value.second.get("<xmlattr>.max_lat", 0.0);
            change.max_lon = value.second.get("<xmlattr>.max_lon", 0.0);
            change.num_changes = value.second.get("<xmlattr>.num_changes", 0);
            change.comments_count = value.second.get("<xmlattr>.comments_count", 0);
            changes.push_back(change);
        }
    }
#endif
}

#ifdef LIBXML
void
ChangeSetFile::on_start_element(const Glib::ustring& name,
                                const AttributeList& attributes)
{
    if (name == "changeset") {
        changeset::ChangeSet change(attributes);
        changes.push_back(change);
        // changes.back().dump();
    } else if (name == "tag") {
        // We ignore most of the tags, as they're not used for OSM stats.
        // Processing a tag requires multiple passes through the loop. The
        // tho tags to look for are 'k' (keyword) and 'v' (value). So when
        // we see a key we want, we have to wait for the next iteration of
        // the loop to get the value.
        bool hashit = false;
        bool comhit = false;
        bool cbyhit = false;
        bool min_lathit = false;
        bool min_lonhit = false;
        bool max_lathit = false;
        bool max_lonhit = false;
        double min_lat = 0.0;
        double min_lon = 0.0;
        double max_lat = 0.0;
        double max_lon = 0.0;

        for (const auto& attr_pair : attributes) {
            if (attr_pair.name == "k" && attr_pair.value == "max_lat") {
                max_lat = std::stod(attr_pair.value);
                max_lathit = true;
            } else if (attr_pair.name == "k" && attr_pair.value == "min_lat") {
                min_lathit = true;
            } else if (attr_pair.name == "k" && attr_pair.value == "max_lon") {
                max_lonhit = true;
            } else if (attr_pair.name == "k" && attr_pair.value == "min_lon") {
                min_lonhit = true;
            } else if (attr_pair.name == "k" && attr_pair.value == "hashtags") {
                hashit = true;
            } else if (attr_pair.name == "k" && attr_pair.value == "comment") {
                comhit = true;
            } else if (attr_pair.name == "k" && attr_pair.value == "created_by") {
                cbyhit = true;
            } else {
                continue;                
            }

            if (hashit && attr_pair.name == "v") {
                hashit = false;                std::size_t pos = attr_pair.value.find('#', 0);
                if (pos != std::string::npos) {
                    char *token = std::strtok((char *)attr_pair.value.c_str(), "#;");
                    while (token != NULL) {
                        token = std::strtok(NULL, "#;");
                        if (token) {
                            changes.back().addHashtags(token);
                        }
                    }
                } else {
                    changes.back().addHashtags(attr_pair.value);
                }
            }
            // Hashtags start with an # of course. The hashtag tag wasn't
            // added till later, so many older hashtags are in the comment
            // field instead.
            if (comhit && attr_pair.name == "v") {
                comhit = false;
                changes.back().addComment(attr_pair.value);
                std::size_t pos = attr_pair.value.find('#', 0);
                if (pos != std::string::npos) {
                    char *token = std::strtok((char *)attr_pair.value.c_str(), "#;");
                    while (token != NULL) {
                        token = std::strtok(NULL, "#;");
                        if (token) {
                            changes.back().addHashtags(token);
                        }
                    }
                }
            }
            if (cbyhit && attr_pair.name == "v") {
                cbyhit = false;
                changes.back().addEditor(attr_pair.value );
            }

            // Get the country the change was made in
            // geoutil::GeoCountry geo = boundaries->inCountry(max_lat, max_lon, min_lat, min_lon);
            // changes.back().countryid = geo.getID();

            // // try {
            //     std::cout << "  Attribute name =" <<  attr_pair.name;
            // }
            // catch(const Glib::ConvertError& ex) {
            //     std::cerr << "ChangeSetFile::on_start_element(): Exception caught while converting name for std::cout: " << ex.what() << std::endl;
            // }
            // try {
            //     std::cout << "    , value = " <<  attr_pair.value << std::endl;
            // }
            // catch(const Glib::ConvertError& ex) {
            //     std::cerr << "ChangeSetFile::on_start_element(): Exception caught while converting value for std::cout: " << ex.what() << std::endl;
            // }
        }
    }
}
#endif  // EOF LIBXML

}       // EOF changeset

