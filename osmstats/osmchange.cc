//
// Copyright (c) 2020, Humanitarian OpenStreetMap Team
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
// * Redistributions of source code must retain the above copyright notice, this
//   list of conditions and the following disclaimer.
//
// * Redistributions in binary form must reproduce the above copyright notice,
//   this list of conditions and the following disclaimer in the documentation
//   and/or other materials provided with the distribution.
//
// * Neither the name of copyright holder nor the names of its
//   contributors may be used to endorse or promote products derived from
//   this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//

// This is generated by autoconf
#ifdef HAVE_CONFIG_H
# include "hotconfig.h"
#endif

#include <string>
#include <vector>
#include <array>
#include <memory>
#include <iostream>
#include <pqxx/pqxx>
#ifdef LIBXML
#  include <libxml++/libxml++.h>
#endif

// The Dump handler
#include <osmium/handler/dump.hpp>

// Allow any format of input files (XML, PBF, ...)
#include <osmium/io/any_input.hpp>

#include <boost/date_time.hpp>
#include "boost/date_time/posix_time/posix_time.hpp"
using namespace boost::posix_time;
using namespace boost::gregorian;
#include <boost/geometry.hpp>
#include <boost/geometry/geometries/point_xy.hpp>
#include <boost/geometry/geometries/linestring.hpp>
#include <boost/geometry/geometries/polygon.hpp>
#include <boost/geometry/geometries/geometries.hpp>
#include <ogrsf_frmts.h>

#include "hotosm.hh"
#include "osmstats/osmchange.hh"
// #include "osmstats/geoutil.hh"

typedef boost::geometry::model::d2::point_xy<double> point_t;
typedef boost::geometry::model::polygon<point_t> polygon_t;
typedef boost::geometry::model::linestring<point_t> linestring_t;

#define BOOST_BIND_GLOBAL_PLACEHOLDERS 1

namespace osmchange {

bool
OsmChange::readChanges(const std::string &osc, bool memory)
{
    try {
        // Default is all entity types: nodes, ways, relations, and changesets
        osmium::osm_entity_bits::type read_types = osmium::osm_entity_bits::all;
        
        // Get entity types from command line if there is a 2nd argument.
        read_types = osmium::osm_entity_bits::nothing;
        std::string types = "fixme!!!!";
        if (types.find('n') != std::string::npos) {
            read_types |= osmium::osm_entity_bits::node;
        }
        if (types.find('w') != std::string::npos) {
            read_types |= osmium::osm_entity_bits::way;
        }
        if (types.find('r') != std::string::npos) {
            read_types |= osmium::osm_entity_bits::relation;
        }
        if (types.find('c') != std::string::npos) {
            read_types |= osmium::osm_entity_bits::changeset;
        }

        // Initialize Reader with file name and the types of entities we want to
        // read.
        osmium::io::Reader reader{"fixme!", read_types};
        
        // The file header can contain metadata such as the program that
        // generated the file and the bounding box of the data.
            osmium::io::Header header = reader.header();
        std::cout << "HEADER:\n  generator=" << header.get("generator") << "\n";
        
        for (const auto& bbox : header.boxes()) {
            std::cout << "  bbox=" << bbox << "\n";
        }

        // Initialize Dump handler.
        osmium::handler::Dump dump{std::cout};

        // Read from input and send everything to Dump handler.
       osmium::apply(reader, dump);

        // You do not have to close the Reader explicitly, but because the
        // destructor can't throw, you will not see any errors otherwise.
        reader.close();
    } catch (const std::exception& e) {
        // All exceptions used by the Osmium library derive from std::exception.
        std::cerr << e.what() << '\n';
        std::exit(1);
    }
}

/// Read a changeset file from disk or memory into internal storage
bool
readChanges(const std::string &osc, bool memory)
{
}

/// The node handler is called for each node in the input data.
void
node(const osmium::Node& node)
{
    // std::cout << "node " << node.id()
    //           << ", Changeset: " << node.changeset()
    //           << ", Version: " << node.version()
    //           << ", UID: " << node.uid()
    //           << ", User: " << node.user()
    //           << ", Timestamp: " << node.timestamp() << std::endl;

    // cache[node.id()] = node.location();
    
    std::string tags;
    for (const osmium::Tag& t : node.tags()) {
        std::cout << "\t" << t.key() << "=" << t.value() << std::endl;
        tags += "\"";
        tags += t.key();
        tags += "\"=>\"";
        // Replace single quotes, as they screw up the query
        std::string tmp = t.value();
        boost::algorithm::replace_all(tmp, "\'", "&quot;");
        tags += tmp;
        tags += "\", ";
    }
    tags = tags.substr(0, tags.size()-2);
}

/// The way handler is called for each way in the input data.
void
way(const osmium::Way& way)
{
    std::cout << "way " << way.id()
              << ", Changeset: " << way.changeset()
              << ", Version: " << way.version()
              << ", UID: " << way.uid()
              << ", User: " << way.user()
              << ", Timestamp: " << way.timestamp() << std::endl;
    // Setup the tags
    std::string tags;
    for (const osmium::Tag& t : way.tags()) {
        std::cout << "\t" << t.key() << "=" << t.value() << std::endl;
        tags += "\"";
        tags += t.key();
        tags += "\"=>\"";
        // Replace single quotes, as they screw up the query
        std::string tmp = t.value();
        boost::algorithm::replace_all(tmp, "\'", "&quot;");
        // Some values have a double quote, which is unnecesary, and
        // screws up XML parsing.
        boost::algorithm::replace_all(tmp, "\"", "");
        tags += tmp;
        tags += "\", ";
    }
    tags = tags.substr(0, tags.size()-2);

    // Setup the node refs
    std::string refs;
    for (const osmium::NodeRef& nref : way.nodes()) {
        refs += std::to_string(nref.ref()) + ", ";
        // const osmium::Location loc = nref.location();
    }
    refs = refs.substr(0, refs.size()-2);

    // Get the bounding box of the way
    linestring_t lines;
    for (const osmium::NodeRef& nref : way.nodes()) {
        std::cout << "ref:  " << nref.ref() << std::endl;
        // If the location data is bad, drop it
        // if (cache[nref.ref()]) {
        //     boost::geometry::append(lines, point_t(cache[nref.ref()].lat(), cache[nref.ref()].lon()));
        // } else {
        //     std::cout << "ERROR: bad location data in " << nref.ref() <<  std::endl;
        // }
    }
}

/// The relation handler is called for each relation in the input data.
void
relation(const osmium::Relation& relation)
{
    std::cout << "rel " << relation.id() << std::endl;
    for (const osmium::Tag& t : relation.tags()) {
        std::cout << "\t" << t.key() << "=" << t.value() << std::endl;
    }
}

}       // EOF osmchange

