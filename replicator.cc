//
// Copyright (c) 2020, Humanitarian OpenStreetMap Team
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
// * Redistributions of source code must retain the above copyright notice, this
//   list of conditions and the following disclaimer.
//
// * Redistributions in binary form must reproduce the above copyright notice,
//   this list of conditions and the following disclaimer in the documentation
//   and/or other materials provided with the distribution.
//
// * Neither the name of copyright holder nor the names of its
//   contributors may be used to endorse or promote products derived from
//   this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//

// This is generated by autoconf
#ifdef HAVE_CONFIG_H
# include "hotconfig.h"
#endif

#include <string>
#include <vector>
#include <array>
#include <memory>
#include <iostream>
#include <pqxx/pqxx>
#include <cstdlib>
#include <sstream>
#include <vector>
#include <cassert>
#include <deque>
#include <list>

#include <boost/date_time.hpp>
#include "boost/date_time/posix_time/posix_time.hpp"
using namespace boost::posix_time;
using namespace boost::gregorian;
#include <boost/program_options.hpp>
#include <boost/property_tree/xml_parser.hpp>
#include <boost/iostreams/filtering_streambuf.hpp>
#include <boost/iostreams/copy.hpp>
#include <boost/filesystem.hpp>
#include <boost/iostreams/filter/gzip.hpp>
#include <boost/iostreams/device/array.hpp>
#include <boost/iostreams/device/back_inserter.hpp>
#include <boost/iostreams/filtering_stream.hpp>

using namespace boost;
namespace opts = boost::program_options;

// #include "hotosm.hh"
#include "osmstats/changeset.hh"
// #include "osmstats/osmstats.hh"
#include "osmstats/geoutil.hh"
#include "osmstats/replication.hh"
#include "data/import.hh"

#define BOOST_BIND_GLOBAL_PLACEHOLDERS 1

// Forward declarations
namespace changeset {
  class ChangeSet;
};

// A helper function to simplify the main part.
template<class T>
std::ostream& operator<<(std::ostream& os, const std::vector<T>& v)
{
    copy(v.begin(), v.end(), std::ostream_iterator<T>(os, " "));
    return os;
}

// This class does all the actual work
class Replicator
{
public:
    /// Create a new instance, and read in the geoboundaries file.
    bool initializeData(void) {
        auto hashes = std::make_shared<std::map<std::string, int>>();
        auto geou = std::make_shared<geoutil::GeoUtil>();
        geou->startTimer();
        // FIXME: this shouldn't be hardcoded
        geou->readFile("../underpass.git/data/geoboundaries.osm", true);
        geou->endTimer();
        changes.setupBoundaries(geou);

        // FIXME: should return a real value
        return false;
    };
    
    /// Initialize the raw_user, raw_hashtags, and raw_changeset tables
    /// in the OSM stats database from a changeset file
    bool initializeRaw(std::vector<std::string> &rawfile, const std::string &database) {
        for (auto it = std::begin(rawfile); it != std::end(rawfile); ++it) {
            changes.importChanges(*it);
        }
    };

    int lookupHashID(const std::string &hash) {
        auto found = hashes->find(hash);
        if (found != hashes->end()) {
            return (*hashes)[hash];
        } else {
            int id = ostats.lookupHashtag(hash);
            return id;
        }
    };
    /// Get the numeric ID of the country by name
    long lookupCountryID(const std::string &country) {
        return geou->getCountry(country).getID();
    };

    // osmstats::RawCountry & findCountry() {
    //     geou.inCountry();
    // };

private:
    osmstats::QueryOSMStats ostats;
    changeset::ChangeSetFile changes;
    std::shared_ptr<geoutil::GeoUtil> geou;
    std::shared_ptr<std::map<std::string, int>> hashes;
};

int
main(int argc, char *argv[])
{
    long sequence = 0;
    std::string server;
    bool encrypted = false;
    ptime timestamp(not_a_date_time);

    try {
        opts::options_description desc("Allowed options");
        desc.add_options()
            ("help,h", "display help")
            ("encrypted,e", "enable HTTPS (the default)")
            ("server,s", "database server (defaults to localhost)")
            ("format,f", "database format (defaults to pgsnapshot)")
            ("statistics,s", "OSM Stats database name (defaults to osmstats)")
            ("osm,o", "OSM database name (defaults to pgsnapshot)")
            ("verbose,v", "enable verbosity")
            ("sequence,s", opts::value<int>(), "Sequence number")
            ("timestamp,t", opts::value<std::string>(), "Starting timestamp")
            ("url,u", opts::value<std::string>(), "Replication File URL")
            ("initialize,r", opts::value<std::vector<std::string>>(), "Initialize OSM Stats Raw data from OSM files")
            ("import,i", opts::value<std::string>(), "Initialize OSM database with datafile")
            ;
        
        opts::positional_options_description p;
        opts::variables_map vm;
        opts::store(opts::command_line_parser(argc, argv).
                  options(desc).positional(p).run(), vm);
        opts::notify(vm);

        Replicator replicator;
        replicator.initializeData();
        
        std::vector<std::string> rawfile;
        
        if (vm.count("help")) {
            std::cout << "Usage: options_description [options]\n";
            std::cout << desc;
            return 0;
        }

        if (vm.count("encrypted")) {
            encrypted = true;
        }

        if (vm.count("sequence")) {
            std::cout << "Sequence is " << vm["sequence"].as<int>() << std::endl;
        }

        if (vm.count("url")) {
            // std::cout << "URL is: " << vm["url"].as<std::vector<std::string> >() << "\n";
        }

        if (vm.count("timestamp")) {
            // std::cout << "Timestamp is: " << vm["timestamp"].as<std::vector<std::string> >() << "\n";
            timestamp = time_from_string(vm["timestamp"].as<std::vector<std::string> >()[0]);
        }

        std::string statistics;
        if (vm.count("initialize")) {
            rawfile = vm["initialize"].as<std::vector<std::string>>();
            replicator.initializeRaw(rawfile, statistics);
        }

        std::string osmdb;
        if (vm.count("osm")) {
            osmdb = vm["osm"].as<std::vector<std::string>>()[0];
        }
        
        if (vm.count("import")) {
            std::string file = vm["import"].as<std::string>();
            import::ImportOSM osm(file, osmdb);
        }

        // FIXME: add logging
        if (vm.count("verbose")) {
            std::cout << "Verbosity enabled.  Level is " << vm["verbose"].as<int>() << std::endl;
        }
    }
    catch(std::exception& e)
    {
        std::cout << e.what() << "\n";
        return 1;
    }

    if (sequence > 0 and !timestamp.is_not_a_date_time()) {
        std::cout << "ERROR: Can only specify a timestamp or a sequence" << std::endl;
        exit(1);
    }

    replication::Replication rep(server, timestamp, sequence);


    
    // std::vector<std::string> files;
    // files.push_back("004/139/998.state.txt");
    // std::shared_ptr<std::vector<std::string>> links = rep.downloadFiles(files, true);
    // std::cout << "Got "<< links->size() << " directories" << std::endl;
    // // links = rep.downloadFiles(*links, true);
    // // std::cout << "Got "<< links->size() << " directories" << std::endl;

    // changeset::StateFile foo("/tmp/foo1.txt", false);
    // changeset::StateFile bar("/tmp/foo2.txt", false);
    // return 0;
}

